import { singleAddressResolverAbi, universalResolverAbi, } from '../../constants/abis.js';
import { ContractFunctionExecutionError, ContractFunctionRevertedError, } from '../../errors/contract.js';
import { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';
import { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';
import { getChainContractAddress } from '../../utils/chain.js';
import { trim } from '../../utils/data/trim.js';
import { toHex } from '../../utils/encoding/toHex.js';
import { namehash } from '../../utils/ens/namehash.js';
import { packetToBytes } from '../../utils/ens/packetToBytes.js';
import { readContract, } from '../public/readContract.js';
export async function getEnsAddress(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_, }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = getChainContractAddress({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver',
        });
    }
    try {
        const res = await readContract(client, {
            address: universalResolverAddress,
            abi: universalResolverAbi,
            functionName: 'resolve',
            args: [
                toHex(packetToBytes(name)),
                encodeFunctionData({
                    abi: singleAddressResolverAbi,
                    functionName: 'addr',
                    args: [namehash(name)],
                }),
            ],
            blockNumber,
            blockTag,
        });
        if (res[0] === '0x')
            return null;
        const address = decodeFunctionResult({
            abi: singleAddressResolverAbi,
            functionName: 'addr',
            data: res[0],
        });
        return trim(address) === '0x00' ? null : address;
    }
    catch (err) {
        if (err instanceof ContractFunctionExecutionError) {
            const reason = err.cause?.reason;
            if (reason?.includes('Wildcard on non-extended resolvers is not supported'))
                return null;
        }
        throw err;
    }
}
//# sourceMappingURL=getEnsAddress.js.map